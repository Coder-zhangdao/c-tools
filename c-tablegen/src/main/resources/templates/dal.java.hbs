package {{config.packageName}}.{{tableInfo.name}}.dal;

{{> [header-comment.java]}}

import java.sql.*;
import java.util.List;
import javax.sql.DataSource;
import com.bixuebihui.test.business.*;
import com.bixuebihui.test.pojo.*;
import com.bixuebihui.jdbc.RowMapperResultReader;
import com.bixuebihui.test.BaseList;


public class {{className}}  extends BaseList<{{pojoClassName}}, {{firstKeyType}}>
{
    {{! writeDALConstructor(tableName); }}
    /**
      * Don't direct use the {{className}}, use {{pojoClassName}}Manager instead.
      */
    protected {{className}}(DataSource ds)
    {
        super(ds);
    }

    {{! writeSql(colData, keyData); }}
    public static final class F{
        {{#each fields}}public static final String {{constantName name}} = "{{name}}";{{/each}}
        public static String[] getAllFields() { return new String[] {
            {{#each fields}}{{constantName name}}{{#unless @last}}, {{/unless}}{{/each}}
            };
        }
    }

    @Override
    protected String getDeleteSql(){
        return "delete from {{tableName}} where {{#each keys}} {{this}}=? {{#unless @last}} and {{/unless}}{{/each}} =? ";
    }

   @Override
   protected String getInsertSql(){
       return "insert into {{tableName}} ( {{#each fields }}
            {{#if (not (and config.isUse_autoincrement this.isAutoIncrement))}}
            {{~ name ~}}
            {{#unless @last}},{{/unless ~}}
            {{/if}}
            {{/each ~}} )
            values ( {{#each fields }}
            {{#if (not (and config.isUse_autoincrement this.isAutoIncrement))}}
                {{~ ? ~}}
                {{#unless @last}},{{/unless ~}}
            {{/if}}
            {{/each ~}}
            )";
   }


    @Override
    protected String getUpdateSql(){
        return "update {{tableName}} set {{#each fields ~}}
            {{#eq config.versionColName name}}
                {{name}}= {{name}} +1
            {{else}}
                {{name}}=?
            {{/eq}}
            {{~#unless @last}},{{/unless~}}
            {{~/each}} {{whereNotLike}}";
    }

    {{! writeObjs(tableName, keyData, colData); }}
   @Override
   protected Object[] getInsertObjs({{pojoClassName}} info){
        return new Object[]{ {{insertObjects}} };
   }

   @Override
   protected Object[] getUpdateObjs({{pojoClassName}}  info){
      return new Object[]{ {{updateObjects}} };
   }

    {{! writeGetTableName(tableName, "getTableName", false); }}
    /**
     * Get table name.
     */
    @Override
    public String getTableName()
    {
       return  "{{tableName}}";
    }

    {{!    writeGetKeyName(getFirstKeyName(keyData)); }}
    /**
    * Get key name.
    */
    @Override
    public String getKeyName()
    {
        return  F.{{constantName firstKeyName}};
    }

    {{!    writeMapRow(tableName, colData); }}
    {{mapRow}}

{{! writeGetSetId(tableName, keyData, colData);}}
    @Override
    public {{firstKeyType}} getId({{pojoClassName}} info) {
        return " + this.getOneId(keyData) + ";
    }

    @Override
    public void setId({{pojoClassName}} info, {{firstKeyType}} id) {
    {{#if hasKey}}
        info.set{{firstUp firstKeyName}}(id);
    {{else}}
        //no key to set, don't this method!
    {{/if}}
    }


    @Override
    public void setIdLong({{pojoClassName}} info, long id) {
    {{#if hasKey}}
        info.set{{firstUp firstKeyName}}(({{firstKeyType}})id);
    {{else}}
        //no key to set, don't this method!
    {{/if}}
    }

{{! writeGetNextKey(keyData, colData); }}

    public {{firstKeyType}} getNextKey(){
    {{#not hasKey}}
        return new java.util.Date().getTime();
    {{else}}
      {{#eq firstKeyType "Timestamp"}}
        return new Timestamp(new java.util.Date().getTime());
      {{/eq}}
      {{#eq firstKeyType "String"}}
        return java.util.UUID.randomUUID().toString();
      {{/eq}}
      {{#gt keys.size 1}}
        throw new IllegalStateException("no autokey for union keys");
      {{/gt}}
    {{/not}}
    }

{{#if hasKey}}

    /* optimistic lock update ! */

    {{#if hasVersionCol}}
    {{! writeUpdate(tableName, keyData, "updateByKeyAndVersion", false, withVersion, colData); }}

    /**
     * Updates the current object values into the database with version condition as an optimistic database lock.
     */
    public boolean updateByKeyAndVersion({{pojoClassName}}  info, Connection cn) throws SQLException
    {
       return 1 == dbHelper.executeNoQuery(getUpdateSql()+" and {{config.versionColName}}=?", new Object[]{
        {{#each fields}}
            {{#eq name config.versionColName}}
            {{~ else ~}}
                info.get{{firstUp name}}(),
            {{/eq}}
        {{/each}}
        {{keyObjects}},info.get{{firstUp config.versionColName}}()
        , cn );
    }

    public boolean updateByKeyAndVersion({{pojoClassName}}  info) throws SQLException
    {
        return 1 == dbHelper.executeNoQuery(getUpdateSql()+" and {{config.versionColName}}=?", new Object[]{
        {{#each fields}}
            {{#eq name config.versionColName}}
            {{~ else ~}}
                info.get{{firstUp name}}(),
            {{/eq}}
        {{/each}}
        {{keyObjects}},info.get{{firstUp config.versionColName}}()
        });
    }
    {{/if}}

    {{! writeDelete(tableName, keyData, "deleteByKey", false, colData);}}
    /**
     * Deletes from the database for table {{tableName}} with connection
     */
    public boolean deleteByKey( {{#each keys}} {{colType tableName name}} {{name}}, {{/each}}  Connection cn ) throws SQLException
    {
        return 1 <= dbHelper.executeNoQuery(getDeleteSql(), new Object[]{ {{#each keys}} {{name}} {{#unless @last}}, {{/unless}} {{/each}} }, cn);
    }

    /**
    * Deletes from the database for table {{tableName}}
    */
    public boolean deleteByKey( {{#each keys}} {{colType tableName name}} {{name}} {{#unless @last}}, {{/unless}}{{/each}}) throws SQLException
    {
        return 1 <= dbHelper.executeNoQuery(getDeleteSql(), new Object[]{ {{#each keys}} {{name}} {{#unless @last}}, {{/unless}} {{/each}} });
    }

{{else}}

    writeDummyUpdate(tableName, "updateByKey");
    writeDummyDelete(tableName, keyData, "deleteByKey", colData);

{{/if}}

//foreign key
        List<ForeignKeyDefinition> foreignKeyData = getTableImportedKeys(tableName);
            for (ForeignKeyDefinition fkEnum : foreignKeyData) {
            writeImportedMethods(tableName, fkEnum, colData);
            }

            foreignKeyData = getTableExportedKeys(tableName);
            for (ForeignKeyDefinition fkEnum : foreignKeyData) {
            writeExportedMethods(fkEnum, getColumnData(setInfo.getTableInfos().get(fkEnum.primaryKeyTableName)).getFields());
            }


            if (config.indexes) {
            List<String> indexData = getTableIndexes(tableName); // updates the indexData
                // variable
                if (isNotEmpty(indexData)) {
                writeSelect(tableName, indexData, "selectByIndex", colData);
                writeSelectAll(tableName, indexData, false, "selectAllLikeIndex", true, colData);

                writeUpdate(tableName, indexData, "updateByIndex", false, false, colData);
                writeUpdate(tableName, indexData, "updateByIndex", true, false, colData);

                writeDelete(tableName, indexData, "deleteByIndex", false, colData);
                writeDelete(tableName, indexData, "deleteByIndex", true, colData);
                writeCount(indexData, false, "countByIndex", colData);
                writeCount(indexData, true, "countLikeIndex", colData);

                }
                }

                writeInsertDummy(tableName, keyData, "insertDummy", colData);
                out("}");


                }
